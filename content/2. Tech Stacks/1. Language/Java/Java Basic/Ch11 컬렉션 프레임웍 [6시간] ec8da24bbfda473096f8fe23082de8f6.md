# Ch11. 컬렉션 프레임웍 [6시간]

[1~2. 컬렉션 프레임웍, 핵심 인터페이스](1~2%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AF%E1%86%A8,%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20a0fd62c63e904bc79a1130d85ec01262.md)

[3~6. Collection, List, Set, Map](3~6%20Collection,%20List,%20Set,%20Map%20982e3143a6fa4899a33aa282472a26c9.md)

[7~11. ArrayList](7~11%20ArrayList%20b5dd1f3cfcf04bf396d8fd3b87fa7378.md)

[12~14. LinkedList](12~14%20LinkedList%2039c125e78b964a3d83e3abe4ac3a3b32.md)

[15~18. Stack과 Queue](15~18%20Stack%E1%84%80%E1%85%AA%20Queue%201b9874b5ab2240eba36c8d127024a7fe.md)

[19~21. Stack과 Queue의 활용](19~21%20Stack%E1%84%80%E1%85%AA%20Queue%E1%84%8B%E1%85%B4%20%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%E1%85%AD%E1%86%BC%2051f79eafe25a4f41801f45d79533a635.md)

[22~24. Iterator, Enumeration, Map](22~24%20Iterator,%20Enumeration,%20Map%2092273388e7624a04800aa1194f5f3f4a.md)

[25~29. Arrays](25~29%20Arrays%20a45b45f1490b4cd38d377d9802ca64d3.md)

[30~33. Comparator와 Comparable](30~33%20Comparator%E1%84%8B%E1%85%AA%20Comparable%206167f533ccff4ab094ad3b167b6b091c.md)

[34~38. HashSet](34~38%20HashSet%20481d88f3bab14066b07f9dd1d0f180bd.md)

[39~45. TreeSet](39~45%20TreeSet%208e03cd04bd8a40b49abe19e02167d7ca.md)

[46~51. HashMap](46~51%20HashMap%20908520b029cd4d27b3be37e897813d7c.md)

[52~54. Collections 클래스](52~54%20Collections%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%2030d8e6ff799b42fa937c6f8b2c93297b.md)

[[JAVA] Array, List의 차이](%5BJAVA%5D%20Array,%20List%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%B5%201ce65c8b294843b99f52cff63616bd21.md)# 1~2. 컬렉션 프레임웍, 핵심 인터페이스

## 컬렉션 프레임웍 (Collection Framework)
---
- 컬렉션 (Collection)
    - 여러 객체(데이터)를 모아 놓은 것
- 프레임웍 (Framework
    - 표준화, 정형화된 체계적인 프로그래밍 방식
- 컬렉션 프레임웍 (Collection Framework)
    - 컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식
    - 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스를 제공
- 컬렉션 클래스 (Collection Class)
    - 다수의 데이터를 저장할 수 있는 클래스 (e.g. Vector, ArrayList, HashSet)

## 컬렉션 프레임웍의 핵심 인터페이스
---
- `List` : 순서가 있는 데이터의 집합. 데이터의 중복을 허용
    - `ArrayList` `LinkedList` `Stack` `Vector` 등
- `Set` : 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않음
    - `HashSet` `TreeSet` 등
- `Map` : 키와 값의 쌍으로 이루어진 데이터의 집합. 순서 유지 X / 키 중복 X / 값 중복 O
    - `HashMap` `TreeMap` `HashTable` `Properties` 등

# 3~6. Collection, List, Set, Map

## Collection 인터페이스의 메서드
---
```java
// 추가
boolean add(Object o)
boolean addAll(Collection c)
// 삭제
void clear()
boolean remove(Object o)
boolean removeAll(Collection c)
boolean retainAll(Collection c)
// 검색
boolean contains(Object o)
boolean containsAll(Collection c)
```

## List 인터페이스 - 순서 O, 중복 O
---
```java
// Collection 인터페이스 메서드 포함
// 추가
void add(int index, Object element)
boolean addAll(int index, Collection c)
// 삭제
Object remove(int index)
// 검색
int indexOf(Object o)
int lastIndexOf(Object o)
// 읽기
Object get(int index)
// 쓰기
Object set(int index, Object element)
// 정렬
void sort(Comparator c)
```

## Set 인터페이스 - 순서 X, 중복 X
---
- Collection 인터페이스 메서드와 동일

## Map 인터페이스 - 순서 X, 중복 (키 X, 값 O)
---
```java
// 추가
Object put(Object key, Object value)
void putAll(Map t)
// 삭제
Object remove(Object key)
// 검색
boolean containsKey(Object key)
boolean containsValue(Object value)
Object get(Object key)
// 읽기
Set entrySet()
Set keySet()
Collection values()
```

# 7~11. ArrayList

## ArrayList
---
- 기존의 Vector 를 개선한 것으로 구현 원리와 기능적으로 동일
    - Vector 는 자체적으로 동기화 처리가 되어 있음
- List 인터페이스를 구현하므로, 저장 순서가 유지되고 중복을 허용
- 데이터의 저장 공간으로 배열을 사용 (배열 기반)

## ArrayList 의 메서드
---
```java
// 생성자
ArrayList()
ArrayList(Collection c)
ArrayList(int initialCapacity)
// 추가
boolean add(Object o)
void add(int index, Object element)
boolean addAll(Collection c)
boolean addAll(int index, Collection c)
// 삭제
boolean remove(Object o)
Object remove(int index)
boolean removeAll(Collection c)
void clear()
// 검색
int indexOf(Object o)
int lastIndexOf(Object o)
boolean contains(Object o)
Object get(int index)
Object set(int index, Object element)
```

## ArrayList 에 저장된 객체의 삭제 과정
---
- 마지막 객체부터 삭제해야 성능 향상 + 전체 삭제 가능
```java
for (int i = list.size() - 1; i >= 0; i--) {
		list.remove(i);
}
```

# 12~14. 패키지, 클래스 패스

## 패키지 (package)
---
- 서로 관련된 클래스의 묵음
- 클래스는 클래스 파일(*.class), 패키지는 폴더, 하위 패키지는 하위 폴더
- 클래스의 실제 이름(full name)은 패키지를 포함. (java.lang.String)

## 패키지의 선언
---
- 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
- 같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.
- 패키지 선언이 없으면 이름없는(unnamed) 패키지에 속하게 된다.

## 클래스 패스 (class path)
---
- 클래스 파일(*.class)의 위치를 알려주는 경로(path)
- 환경변수 classpath로 관리하며, 경로간의 구분자는 ‘;’를 사용
    - classpath(환경변수)에 패키지의 루트를 등록해줘야 함.

# 15~18. StringBuffer 클래스

## StringBuffer 클래스
---
- String 처럼 문자형 배열(char[])을 내부적으로 가지고 있음
- 그러나 String 과 달리 내용을 변경할 수 있음 (mutable)

## StringBuffer의 생성자
---
- 배열은 길이 변경불가. 공간이 부족하면 새로운 배열 생성
- StringBuffer는 저장할 문자열의 길이를 고려해서 적절한 크기로 생성해야 함
```java
public StringBuffer(int length) {
	value = new char[length];
	shared = false;
}
public StringBuffer() {
	this(16); // 버퍼의 크기 미지정 시 16으로 생성
}
public StringBuffer(String str) {
	this(str.length() + 16); // 지정한 문자열보다 16 크게 생성
	append(str);
}
```

## StringBuffer의 변경
---
- StringBuffer 는 String 과 달리 내용 변경이 가능
- append() 는 지정된 내용을 StringBuffer 에 추가 후, StringBuffer 의 참조를 반환
```java
StringBuffer sb2 = sb.append("ZZ");
System.out.println(sb);  // abc123ZZ
System.out.println(sb2); // abc123ZZ
// 아래와 같이 써도된다
StringBuffer sb = new StringBuffer("abc");
sb.append("123").append("ZZ");
```

## StringBuffer의 비교
---
- StringBuffer 는 equals() 가 오버라이딩 되어 있지 않음 (주소 비교)
- StringBuffer 을 String 으로 변환 후에 equals() 로 비교
```java
StringBuffer sb = new StringBuffer("abc");
StringBuffer sb2 = new StringBuffer("abc");
System.out.println(sb.equals(sb2)); // false
String s = sb.toString();
String s2 = sb2.toString();
System.out.println(s.equals(s2)); // true
```

# 19~21. Stack과 Queue의 활용

## Stack과 Queue의 활용
---
### Stack 활용의 예
- 수식계산
- 수식괄호검사
- 워드프로세서의 undo/redo
- 웹브라우저의 뒤로/앞으로
### Queue 활용의 예
- 최근사용문서
- 인쇄작업 대기목록
- 버퍼

# 22~24. Iterator, Enumeration, Map

## Iterator, ListIterator, Enumeration
---
### 개요
- 컬렉션에 저장된 데이터를 접근하는데 사용되는 인터페이스
- Enumeration 은 Iterator 의 구버전 (잘안씀)
- ListIterator 는 Iterator 의 접근성을 향상 (단방향 → 양방향) (잘안씀)
```java
// 읽어 올 요소가 남아있는지 확인
boolean hasNext()
// 다음 요소를 읽어 옴
Object next()
```
### 개념
- 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화한 것
    - List, Set, Map 모두 읽어오는 방법이 다르기 때문에 위와 같은 인터페이스를 사용
### 사용법
- 컬렉션에 iterator()를 호출해서 iterator를 구현한 객체를 얻어서 사용
```java
List list = new ArrayList();
Iterator it = list.iterator();
while (it.hasNext()) {             // 읽어 올 요소가 있는지 확인
		System.out.println(it.next()); // 다음 요소를 읽어옴
}
```

## Map과 Iterator
---
- Map에는 iterator()가 없다.
    - Map은 Collection의 자손이 아님
    - keySet(), entrySet(), values()를 호출해야 함
```java
Map map = new HashMap();
Iterator it = map.entrySet().iterator();
```

# 25~29. Arrays

## Arrays - 배열을 다루기 편리한 메서드(static) 제공
---
1. 배열의 출력
```java
int[] arr  = {1,2,3,4,5};
String list = Arrays.toString(arr); // [1,2,3,4,5] 반환
```
1. 배열의 복사
```java
int[] arr  = {1,2,3,4,5};
int[] arr2 = Arrays.copyOf(arr, 3);         // arr2 = [0,1,2]
int[] arr3 = Arrays.copyOfRange(arr, 2, 4); // arr3 = [2,3]
```
1. 배열 채우기
```java
int[] arr = new int[5];
Arrays.fill(arr, 9);                                     // arr = [9,9,9,9,9]
Arrays.setAll(arr, (i) -> (int)(Math.random() * 5) + 1); // arr = [1,5,2,1,1]
```
1. 배열의 정렬과 검색
```java
int[] arr = {3,2,0,1,4};
int idx = Arrays.binarySearch(arr, 2);    // idx = -5 <- 잘못된 결과
// 이진탐색은 정렬되어 있을 때만 가능
Arrays.sort(arr);                         // arr 정렬
System.out.println(Arrays.toString(arr)); // [0,1,2,3,4]
int idx = Arrays.binarySearch(arr, 2);    // idx = 2 <- 올바른 결과
```
1. 다차원 배열의 출력
```java
int[]   arr   = {0,1,2,3,4};
int[][] arr2D = {{11,22}, {21,22}};
System.out.println(Arrays.toString(arr));       // [0, 1, 2, 3, 4]
System.out.println(Arrays.deepToString(arr2D)); // [[11, 12], [21, 22]]
```
1. 다차원 배열의 비교
```java
String[][] str2D  = new String[][]{{"aaa","bbb"},{"AAA","BBB"}};
String[][] str2D2 = new String[][]{{"aaa","bbb"},{"AAA","BBB"}};
System.out.println(Arrays.equals(str2D, str2D2));     // false
System.out.println(Arrays.deepEquals(str2D, str2D2)); // true
```
1. 배열을 List로 변환
```java
List list = Arrays.asList(new Integer[]{1,2,3,4,5}); // list = [1,2,3,4,5]
List list = Arrays.asList(1,2,3,4,5);                // list = [1,2,3,4,5]
list.add(6) // UnsupportedOperationException 예외 발생. 읽기 전용이기 때문에
List list = new ArrayList(Arrays.asList(1,2,3,4,5)); // 새로운 ArrayList. 변경가능
```

# 30~33. 쓰레드의 동기화

## 쓰레드의 동기화(synchronization)
---
- 멀티 쓰레드 프로세스에서는 다른 쓰레드의 작업에 영향을 미칠 수 있음
- 진행중인 작업이 다른 쓰레드에게 간섭받지 않게 하려면 ‘동기화’가 필요
<aside>
💡 쓰레드의 동기화 - 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막는 것
</aside>
- 동기화하려면 간섭받지 않아야 하는 문장들을 ‘임계 영역’으로 설정
- 임계 영역은 락을 얻은 단 하나의 쓰레드만 출입 가능 (객체 1개에 락 1개)

## synchronized를 이용한 동기화
---
- synchronized로 임계영역(lock이 걸리는 영역)을 설정하는 방법 2가지
```java
// 1. 메서드 전체를 임계 영역으로 지정
public synchronized void calcSum() {
		...
}
// 2. 특정한 영역을 임계 영역으로 지정
synchronized(객체의 참조변수) {
		...
}
```

# 34~38. HashSet

## HashSet - 순서 X, 중복 X
---
### HashSet
- Set 인터페이스를 구현한 대표적인 컬렉션 클래스
- 순서를 유지하려면, LinkedHashSet 클래스를 사용
### TreeSet
- 범위 검색과 정렬에 유리한 컬렉션 클래스
- HashSet 보다 데이터 추가, 삭제에 시간이 더 걸림

## HashSet - 주요 메서드
---
```java
// 생성자
HashSet()
HashSet(Collection c)
HashSet(int initialCapacity)                   // 초기용량 설정
HashSet(int initialCapacity, float loadFactor) // 언제 용량을 늘릴건지
// 추가
boolean add(Object o)
boolean addAll(Collection c) // 합집합
// 삭제
boolean remove(Object o)
boolean removeAll(Collection c) // 교집합
// 모두삭제
void clear()
// 조건부삭제
boolean retainAll(Collection c) // 차집합
// 포함 여부 확인
boolean contains(Object o)
boolean containsAll(Collection c) // 여러 객체를 모두 포함하는지
// 비었는지 확인
boolean isEmpty()
// 저장된 객체 수 확인
int size()
// 객체배열로 반환
Object[] toArray()
Object[] toArray(Object[] a)
```

## HashSet - 예제 3
---
- HashSet은 객체를 저장하기 전에 기존에 같은 객체가 있는지 확인
    - 같은 객체가 없으면 저장, 있으면 저장 X
- `boolean add(Object o)`는 저장할 객체의 `equals()`와 `hashCode()`를 호출
    - `equals()`와 `hashCode()`가 오버라이딩 되어 있어야 함
```java
public boolean equals(Object o) {
		if (!(obj instanceof Person)) {
				return false;
		}
		Person tmp = (Person)obj;
		return name.equals(tmp.name) && age==tmp.age;
}
public int hashCode() {
		return Objects.hash(name, age);
}
```

# 39~45. TreeSet

## TreeSet - 범위 탐색, 정렬
---
- 이진 탐색 트리(binary search tree)로 구현. 범위 탐색과 정렬에 유리.
- 이진 트리는 모든 노드가 최대 2개의 하위 노드를 갖음
    - 각 노드가 트리 형태로 연결 (LinkedList의 변형)

## 이진 탐색 트리(binary search tree)
---
- 부모보다 작은 값은 왼쪽, 큰 값은 오른쪽에 저장
- 데이터가 많아질수록 추가, 삭제에 시간이 더 걸림 (비교 횟수 증가)

## TreeSet - 데이터 저장과정 `boolean add(Object o)`
---
- TreeSet 에 7,4,9,1,5 의 순서로 데이터를 저장할 때
![[Untitled%209.png]]

## TreeSet - 주요 생성자와 메서드
---
```java
// 생성자
TreeSet()
HashSet(Collection c)
TreeSet(Comparator comp) // 주어진 정렬기준으로 정렬하는 TreeSet 생성
Object first() // 정렬된 순서에서 첫번째 객체 반환
Object last()  // 정렬된 순서에서 마지막 객체 반환
Object ceiling(Object o) // 지정된 객체와 같은 객체를 반환. 없으면 가장 가까운 큰 값 반환
Object floor(Object o)   // 지정된 객체와 같은 객체를 반환. 없으면 가장 가까운 작은 값 반환
Object higher(Object o) // 지정된 객체보다 큰 가장 가까운 값 반환
Object lower(Object o)  // 지정된 객체보다 작은 가장 가까운 값 반환
SortedSet subSet(Object fromElement, Object toElement) // 범위 검색의 결과 반환
SortedSet headSet(Object toElement)                    // 지정된 객체보다 작은 객체들
SortedSet tailSet(Object fromElement)                  // 지정된 객체보다 큰 객체들
```

# 46~51. HashMap

## HashMap과 Hashtable - 순서 X, 중복(키 X, 값 O)
---
- Map 인터페이스를 구현. 데이터를 키와 값의 쌍으로 저장
- HashMap(동기화 X)은 Hashtable(동기화O)의 신버전
### HashMap
- Map 인터페이스를 구현한 대표적인 컬렉션 클래스
- 순서를 유지하려면 `LinkedHashMap` 클래스 사용
### TreeMap
- 범위 검색과 정렬에 유리한 컬렉션 클래스
- HashMap 보다 데이터 추가, 삭제에 시간이 더 걸림

## HashMap의 키(key)와 값(value)
---
- 해싱(hashing) 기법으로 데이터를 저장. 데이터가 많아도 검색이 빠름
- Map 인터페이스를 구현. 데이터를 키와 값의 쌍으로 저장
```java
public class HashMap extends AbstractMap implements Map, Cloneable, Serializable {
		transient Entry[] table;
		...
		static class Entry implements Map.Entry {
				final Object key;
				Object value;
				...
		}
}
```

## 해싱(hashing)
- 해시함수(hash function)로 해시테이블(hash table)에 데이터를 저장, 검색
- 해시테이블은 배열과 링크드 리스트가 조합된 형태
- 해시함수는 같은 키에 대해 항상 같은 해시코드를 반환해야 함 (저장 후 검색을 위해)
- 서로 다른 키일지라도 같은 값의 해시코드를 반환할 수 있음

## HashMap - 주요 메서드
---
```java
// 생성자
HashMap()
HashMap(int initialCapacity)                   // 초기용량 설정
HashMap(int initialCapacity, float loadFactor) // 언제 용량을 늘릴건지
HashMap(Map m)                                 // 다른 Map을 HashMap으로 변경
// 추가
Object put(Object key, Object value)
void putAll(Map m)
// 삭제
Object remove(Object key)
// 수정
Object replace(Object key, Object value)
boolean replace(Object key, Object oldValue, Object newValue)
// 읽어오기
Set entrySet()
Set keySet()
Collection values()
// 탐색
Object get(Object key)
Object getOrDefault(Object key, Object defaultValue)
boolean containsKey(Object key)
boolean containsValue(Object value)
```

# 52~54. Collections 클래스

## Collections - 컬렉션을 위한 메서드(static)를 제공
---
1. 컬렉션 채우기, 복사, 정렬, 검색 - fill(), copy(), sort(), binarySearch() 등
2. 컬렉션의 동기화 - synchronizedXXX()
3. 변경불가(readOnly) 컬렉션 만들기 - unmodifiableXXX()
4. 싱글톤 컬렉션 만들기(객체 1개만 저장) - singletonXXX()
5. 한 종류의 객체만 저장하는 컬렉션 만들기 - checkedXXX()

# [JAVA] Scanner, BufferedReader
# Scanner
- 공란과 줄바꿈 모두 입력값의 경계로 인식하기 때문에 쉬운 데이터 입력이 가능
- 사용하는 함수에 따라 데이터 타입을 결정할 수 있음 (문자열 파싱 기능 제공)
```java
import java.util.Scanner;
public class study {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		System.out.println("원하는 숫자를 입력하세요");
		String input = scanner.nextLine();
		int num = Integer.parseInt(input);
		System.out.println(num);
	}
}
```
# BufferedReader
- InputStreamReader 에 버퍼링 기능이 추가된 클래스
    - InputStreamReader 는 문자열을 Character 단위로 읽음
- 일정한 크기의 데이터를 한 번에 읽어와 버퍼에 보관 후 버퍼에서 데이터를 가져오는 방식
- 라인 단위로 입력 받고 String 타입으로만 입력됨
- 속도가 빠르다는 장점이 있음
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class study {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // 선언
		String s = br.readLine(); 
		int i = Integer.parseInt(br.readLine()); 
		
		System.out.println("String : " + s);
		System.out.println("Int : " + i);
		
	}
}
```
# Difference
![[Untitled%2014.png]]
![[Untitled%2015.png]]

