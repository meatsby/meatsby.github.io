# 39. 인터페이스의 장점

## 인터페이스의 장점

---

- 두 대상(객체) 간의 ‘연걸, 대화, 소통’을 돕는 ‘중간 역할’
- 선언(설계)와 구현을 분리 시킬 수 있음

```java
// 껍데기 + 알맹이
class B {
	public void method() {
		System.out.println("methodInB");
	}
}
```

```java
// 껍데기
interface I {
	public void method();
}

// 알맹이
class B implements I {
	public void method() {
		System.out.println("methodInB");
	}
}
```

- 인터페이스 덕분에 B가 변경되어도 A는 안 바꿀 수 있게 된다. (느슨한 결합)
    - A가 B에 의존적일 때

```java
class A {
	public void methodA(B b) {
		b.methodB();
	}
}

class B {
	public void methodB() {
		System.out.println("methodB()");
	}
}

class InterfaceTest {
	public static void main(String args[]) {
		A a = new A();
		a.methodA(new B());
	}
}
```

```java
// B와 관계 없어진 A
class A {
	public void methodA(I i) {
		i.methodB();
	}
}

interface I {
	void methodB();
}

class B implemetns I {
	public void methodB() {
		System.out.println("methodB()");
	}
}

// B를 C로 변경 시 A는 변경 없음
class C implemetns I {
	public void methodB() {
		System.out.println("methodB() in C");
	}
}
```

- 개발 시간을 단축
    - A가 B에 의존적일 때 B의 인터페이스를 미리 구현함으로써 B가 완성되기 전 A를 개발
- 변경에 유리한 유연한 설계가 가능
- 표준화가 가능 (A가 의존하는 B와 C의 공통 표준을 요구할 수 있음)
- 서로 관계없는 클래스들을 관계를 맺어줄 수 있음

```java
// GroundUnit 자손으로 Marine, SCV, Tank 가 있고
// SCV, Tank 만 repair() 메서드를 추가하고 싶을 때
// repairable 이라는 인터페이스를 구현함으로써 관계없는 클래스 간에 공통점 생성 가능

void repair(Repariable r) {
	if (r instanceof Unit) {
		Unit u = (Unit)r;
		while (u.hitPoint != u.MAX_HP) {
			u.hitPoint++;
		}
	}
}
```