# Ch12. 지네릭스, 열거형, 애너테이션 [3.5시간]

[1. 지네릭스(Generics)란?](1%20%E1%84%8C%E1%85%B5%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3(Generics)%E1%84%85%E1%85%A1%E1%86%AB%20823bd7e7946a46a4ae0ae3c4d8496ea8.md)

[2~3. 타입 변수](2~3%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20b95bf0f3bc99467f893a8821b41b02b2.md)

[4~5. 지네릭스 용어, 타입과 다형성](4~5%20%E1%84%8C%E1%85%B5%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%20%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8B%E1%85%A5,%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%20268f825f6b544342b47288c5115584a6.md)

[7~8. Iterator, HashMap과 지네릭스](7~8%20Iterator,%20HashMap%E1%84%80%E1%85%AA%20%E1%84%8C%E1%85%B5%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%202d14412229834413b58ff167074dc577.md)

[9~11. 제한된 지네릭 클래스, 제약](9~11%20%E1%84%8C%E1%85%A6%E1%84%92%E1%85%A1%E1%86%AB%E1%84%83%E1%85%AC%E1%86%AB%20%E1%84%8C%E1%85%B5%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3,%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A3%E1%86%A8%20b8dc32eb2f444a5dade661df01dbb2a5.md)

[12~14. 와일드 카드, 지네릭 메서드](12~14%20%E1%84%8B%E1%85%AA%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%83%E1%85%B3%20%E1%84%8F%E1%85%A1%E1%84%83%E1%85%B3,%20%E1%84%8C%E1%85%B5%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3%20fb9238c83d6c44fc80b49e54a4648b45.md)

[15~16. 지네릭 형변환](15~16%20%E1%84%8C%E1%85%B5%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%20%E1%84%92%E1%85%A7%E1%86%BC%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%2002e4894648ab4012abbdbbe6fa1da8fe.md)

[17~20. 열거형](17~20%20%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%80%E1%85%A5%E1%84%92%E1%85%A7%E1%86%BC%20e90ffaa4e5304b5099cb63719d907ddc.md)

[21~22. 열거형 멤버 추가하기](21~22%20%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%80%E1%85%A5%E1%84%92%E1%85%A7%E1%86%BC%20%E1%84%86%E1%85%A6%E1%86%B7%E1%84%87%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20b4f6829eef2b4bb3bad229e76ae4a63a.md)

[23~26. 표준 애너테이션](23~26%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20%E1%84%8B%E1%85%A2%E1%84%82%E1%85%A5%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20bf480ba8c91b43a59b588c09e70eb367.md)

[29~33. 메타 애너테이션](29~33%20%E1%84%86%E1%85%A6%E1%84%90%E1%85%A1%20%E1%84%8B%E1%85%A2%E1%84%82%E1%85%A5%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%2054aab37cd34e4a2381fe67544944050b.md)

[34~37. 애너테이션 타입 정의, 요소](34~37%20%E1%84%8B%E1%85%A2%E1%84%82%E1%85%A5%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%B4,%20%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9%20763f0725f5684fd3bea178a6dc9c4106.md)# 1. 지네릭스(Generics)란?

## 지네릭스(Generics)란?
---
- 컴파일 시 타입을 체크해 주는 기능(compile-time type check) - JDK1.5
- 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줌
```java
ArrayList<Tv> tvList = new ArrayList<Tv>();
tvList.add(new Tv());    // OK.
tvList.add(new Audio()); // 컴파일 에러.
// Tv t = (Tv)tvList.get(0);
Tv t = tvList.get(0); // 형변환 불필요
```
- `RuntimException`인 `ClassCastException`을 `Compiletime`에서 처리하기 위해
- e.g. `String str = null;`보다 `String str = “”;`로 초기화하여 `NullPointerException` 회피

# 2~3. 타입 변수

## 타입 변수
---
- 클래스를 작성할 때, Object 타입 대신 타입 변수(E)를 선언해서 사용

## 타입 변수에 대입하기
---
- 객체 생성 시, 타입 변수(E) 대신 실제 타입(Tv)을 지정(대입)
```java
// 타입 변수 E 대신에 실제 타입 Tv를 대입
ArrayList<Tv> tvList = new ArrayList<Tv>();
```
- 타입 변수 대신 실제 타입이 지정되면, 형변환 생략가능

# 4~5. 지네릭스 용어, 타입과 다형성

## 지네릭스 용어
---
- `Box<T>` 지네릭 클래스. ‘T의 Box’ 또는 ‘T Box’라고 읽음
- `T` 타입 변수 또는 타입 매개변수. (T는 타입 문자)
- `Box` 원시 타입 (raw type). 일반 클래스

## 지네릭스 타입과 다형성
---
- 참조 변수와 생성자의 대입된 타입은 일치해야 함
```java
ArrayList<Tv>      list = new ArrayList<Tv>(); // OK.
ArrayList<Product> list = new ArrayList<Tv>(); // 에러.
```
- 지네릭 클래스간의 다형성은 성립. (여전히 대입된 타입은 일치해야 함)
```java
List<Tv> list = new ArrayList<Tv>();  // OK. 다형성. ArrayList가 List를 구현
List<Tv> list = new LinkedList<Tv>(); // OK. 다형성. LinkedList가 List를 구현
```
- 매개변수의 다형성도 성립
```java
ArrayList<Product> list = new ArrayList<Product>();
list.add(new Product());
list.add(new Tv());
list.add(new Audio());
```

# 7~8. Iterator, HashMap과 지네릭스

## Iterator<E>
---
- 클래스를 작성할 때, Object 타입 대신 T 와 같은 타입 변수를 사용
```java
Iterator<Student> it = list.iterator();
while (it.hasNext()) {
		Student s = it.next(); // 형변환 생략 가능
}
```

## HashMap<K, V>
---
- 여러 개의 타입 변수가 필요한 경우, 콤마를 구분자로 선언
```java
HashMap<String, Student> map = new HashMap<String, Student>();
map.put("자바왕", new Student("자바왕", 1, 1, 100, 100, 100));
```

# 9~11. 제한된 지네릭 클래스, 제약

## 제한된 지네릭 클래스
---
- extends로 대입할 수 있는 타입을 제한
```java
class FruitBox<T extends Fruit> { // Fruit의 자손만 타입으로 지정가능
		ArrayList<T> list = new ArrayList<T>();
}
```
- 인터페이스인 경우에도 extends를 사용
```java
interface Eatable {}
class FruitBox<T extends Eatable> { ... }
```

## 지네릭스의 제약
---
- 타입 변수에 대입은 인스턴스 별로 다르게 가능
```java
Box<Apple> appleBox = new Box<Apple>();
Box<Grape> grapeBox = new Box<Grape>();
```
1. static 멤버에 타입 변수 사용 불가 (인스턴스 공통이기 때문에)
```java
class Box<T> {
		static T item; // 에러.
		static int compare(T, t1, T t2) { ... } // 에러.
}
```
1. 배열 생성 시 타입 변수 사용불가. 타입 변수로 배열 선언은 가능
```java
class Box<T> {
		T[] itemArr; // OK. T타입의 배열을 위한 참조변수
				...
		T[] toArray() {
				T[] tmpArr = new T[itemArr.length]; // 에러. 지네릭 배열 생성불가
				...
		}
}
```

# 12~14. 패키지, 클래스 패스

## 패키지 (package)
---
- 서로 관련된 클래스의 묵음
- 클래스는 클래스 파일(*.class), 패키지는 폴더, 하위 패키지는 하위 폴더
- 클래스의 실제 이름(full name)은 패키지를 포함. (java.lang.String)

## 패키지의 선언
---
- 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
- 같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.
- 패키지 선언이 없으면 이름없는(unnamed) 패키지에 속하게 된다.

## 클래스 패스 (class path)
---
- 클래스 파일(*.class)의 위치를 알려주는 경로(path)
- 환경변수 classpath로 관리하며, 경로간의 구분자는 ‘;’를 사용
    - classpath(환경변수)에 패키지의 루트를 등록해줘야 함.

# 15~16. 지네릭 형변환

## 지네릭 타입의 형변환
---
- 지네릭 타입과 원시 타입 간의 형변환은 바람직 하지 않음
```java
Box<Object> objBox = null;
Box box = (Box)objBox;     // OK. 지네릭 타입 -> 원시 타입. 경고 발생
objBox = (Box<Object>)box; // OK. 원시 타입 -> 지네릭 타입. 경고 발생
objBox = (Box<Object>)strBox; // 에러. Box<String> -> Box<Object>
strBox = (Box<String>)objBox; // 에러. Box<Object> -> Box<String>
```
- 와일드 카드가 사용된 지네릭 타입으로는 형변환 가능
```java
Box<Object>         objBox = (Box<Object>)new Box<String>(); // 에러. 형변환 불가능
Box<? extends Object> wBox = (Box<? extends Object>)new Box<String>(); // OK.
Box<? extends Object> wBox = new Box<String>(); // 위 문장과 동일
// 매개변수로 FruitBox<Fruit>, FruitBox<Apple>, FruitBox<Grape> 등이 가능
static Juice makeJuice<FruitBox<? extends Fruit> box) { ... }
FruitBox<? extends Fruit> box = new FruitBox<Fruit>(); // OK.
FruitBox<? extends Fruit> box = new FruitBox<Apple>(); // OK.
```

## 지네릭 타입의 제거
---
- 컴파일러는 지네릭 타입을 제거하고, 필요한 곳에 형변환을 넣음
1. 지네릭 타입의 경계(bound)를 제거
2. 지네릭 타입 제거 후 타입이 불일치하면, 형변환 추가
3. 와일드 카드가 포함된 경우, 적절한 타입으로 형변환 추가

# 17~20. 제어자, static, final, abstract

## 제어자(modifier)
---
- 클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여
    - 접근 제어자 - `public` `protected` `(default)` `private`
    - 그 외 - `static` `final` `abstract` `native` `transient` `synchronized` `volatile` `strictfp`
- 하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만)
    ```java
    public class ModifierTest {
    	public static final int WIDTH = 200;
    	public static void main(String[] args) {
    		System.out.println("WIDTH=" + WIDTH);
    	}
    }
    ```

## static - 클래스의, 공통적인
---
| 대상 | 의미 |
| --- | --- |
| 멤버변수 | 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
클래스가 메모리에 로드될 때 생성된다. |
| 메서드 | 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다. |

## final - 마지막의, 변경될 수 없는
---
| 대상 | 의미 |
| --- | --- |
| 클래스 | 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다. |
| 메서드 | 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다. |
| 멤버변수
지역변수 | 변수 앞에 final 이 붙으면, 값을 변경할 수 없는 상수가 된다. |
```java
final class AbstractTest {   // 조상이 될 수 없는 클래스
	final int MAX_SIZE = 10;   // 값을 변경할 수 없는 멤버변수 (상수)
	final void getMaxSize() {  // 오버라이딩을 할 수 없는 메서드 (변경불가)
		final int LV = MAX_SIZE; // 값을 변경할 수 없는 지역변수 (상수)
		return MAX_SIZE;
	}
}
```

## abstract - 추상의, 미완성의
---
| 대상 | 의미 |
| --- | --- |
| 클래스 | 클래스 내에 추상 메서드가 선언되어 있음을 의미한다. |
| 메서드 | 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다. |
```java
abstract class AbstractTest { // 추상 클래스 (추상 메서드를 포함한 클래스)
	abstract void move();       // 추상 메서드 (구현부가 없는 메서드)
}
AbstractTest a = new AbstractTest(); // 에러. 추상 클래스의 인스턴스 생성불가
```

# 21~22. 열거형 멤버 추가하기

## 열거형 멤버 추가하기
---
- 불연속적인 열거형 상수의 경우, 원하는 값을 괄호 안에 적음
```java
enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10) }
```
- 괄호를 사용하려면, 인스턴스 변수와 생성자를 새로 추가해 줘야 함
```java
enum Direction {
		EAST(1), SOUTH(5), WEST(-1), NORTH(10);
		private final int value;
		Direction(int value) {
				this.value = value;
		}
		public int getValue() {
				return value;
		}
}
```
- 열거형의 생성자는 묵시적으로 private 이기 때문에, 외부에서 객체 생성 불가
```java
Direction d = new Direction(1); // 에러. 열거형의 생성자는 외부에서 호출불가
```

# 23~26. 표준 애너테이션

## 애너테이션이란?
---
- 주석처럼 프로그래밍 언어에 영향을 미치지 않으며, 유용한 정보를 제공

## @Override
---
- 오버라이딩을 올바르게 했는지 컴파일러가 체크하게 함
- 오버라이딩할 때 메서드 이름을 잘못 적는 실수를 하는 경우가 많음

## @Deprecated
---
- 앞으로 사용하지 않을 것을 권장하는 필드나 메서드에 붙힘
- @Deprecated의 사용 예, Date 클래스의 getDate()

## @FunctionalInterface
---
- 함수형 인터페이스에 붙이면, 컴파일러가 올바르게 작성했는지 체크
    - 함수형 인터페이스에는 하나의 추상메서드만 가져야 한다는 제약이 있음

## @SuppressWarning
---
- 컴파일러의 경고 메시지가 나타나지 않게 억제
- 괄호 안에 억제하고자 하는 경고의 종류를 문자열로 지정

# 29~33. 메타 애너테이션

## 메타 애너테이션이란?
---
- 애너테이션을 위한 애너테이션

## @Target
---
- 애너테이션을 정의할 때, 적용대상 지정에 사용

## @Retention
---
- 애너테이션이 유지되는 기간을 지정하는데 사용

## @Documented, @Inherited
---
- javadoc으로 작성한 문서에 포함시키려면 @Documented
- 애너테이션을 자손 클래스에 상속하고자할 때, @Inherited

## @Repeatable
---
- 반복해서 붙일 수 있는 애너테이션을 정의할 때 사용

# 34~37. 애너테이션 타입 정의, 요소

## 애너테이션 타입 정의하기
---
- 애너테이션을 직접 만들어 쓸 수 있음
```java
@interface DateTime {
		String yymmdd();
		String hhmmss();
}
```
- 애너테이션의 메서드는 추상 메서드이며, 애너테이션을 적용할 때 지정 (순서 X)
```java
// 정의
@interface TestInfo {
		int count();
		String testedBy();
		String[] testTools();
		TestType testType();
		DateTime testDate();
}
// 사용
@TestInfo(
		count = 3, testedBy = "Kim",
		testTools = {"JUnit", "AutoTester"},
		testType = TestType.FIRST,
		testDate = @DateTime(yymmdd = "160101", hhmmss = 235959")
)
public class NewClass { ... }
```

## 애너테이션의 요소
---
- 적용 시 값을 지정하지 않으면, 사용될 수 있는 기본값 지정 가능 (null 제외)
```java
@interface TestInfo {
		int count() default 1;  // 기본값을 1로 지정
}
@TestInfo // @TestInfo(count=1)과 동일
public class NewClass { ... }
```
- 요소가 하나이고 이름이 value일 때, 요소의 이름 생략 가능
```java
@interface TestInfo {
		String value();
}
@TestInfo("passed") // @TestInfo(value="passed")와 동일
public class NewClass { ... }
```
- 요소의 타입이 배열인 경우, 중괄호 사용
```java
@interface TestInfo {
		String[] testTools();
}
@TestInfo(testTools = {"JUnit", "AutoTester"})
@TestInfo(testTools = "JUnit")
@TestInfo(testTools = {}) // 값이 없을 경우 빈괄호 필요
```

## 모든 애너테이션의 조상
---
- Annotation은 모든 애너테이션의 조상이지만 상속 불가
- 사실 Annotation은 인터페이스

## 마커 애너테이션
---
- 요소가 하나도 정의되지 않은 애너테이션
```java
public @interface Override{}
public @interface Test{}
```

## 애너테이션 요소의 규칙
---
- 애너테이션의 요소를 선언할 때 규칙
    - 요소의 타입은 기본형, String, enum, 애너테이션, Class 만 허용
    - 괄호 안에 매개변수 선언 X
    - 예외 선언 X
    - 요소를 타입 매개변수로 정의 X

